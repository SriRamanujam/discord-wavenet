use std::{
    io::Write,
    path::PathBuf,
    sync::{
        atomic::{AtomicUsize, Ordering},
        Arc,
    },
    time::Duration,
};

use anyhow::anyhow;
use anyhow::Context as anyhowContext;
use googapis::google::cloud::texttospeech::v1::{
    synthesis_input::InputSource, text_to_speech_client::TextToSpeechClient, AudioConfig,
    AudioEncoding, ListVoicesRequest, SynthesisInput, SynthesizeSpeechRequest,
    VoiceSelectionParams,
};
use gouth::Builder;
use serenity::{
    async_trait,
    client::{Context, EventHandler},
    framework::{
        standard::{
            macros::{command, group},
            Args, CommandResult,
        },
        StandardFramework,
    },
    http::Http,
    model::{channel::Message, id::ChannelId, prelude::Ready},
    prelude::TypeMapKey,
    Client,
};
use songbird::{
    create_player, Event, EventContext, EventHandler as VoiceEventHandler, SerenityInit, TrackEvent,
};
use tonic::{
    metadata::MetadataValue,
    transport::{Certificate, Channel, ClientTlsConfig},
    Request,
};

async fn create_google_api_client(
    api_path: impl Into<PathBuf>,
) -> anyhow::Result<TextToSpeechClient<Channel>> {
    let token = Builder::new()
        .file(api_path)
        .build()
        .context("Could not load Google API credentials")?;

    let tls_config = ClientTlsConfig::new()
        .ca_certificate(Certificate::from_pem(googapis::CERTIFICATES))
        .domain_name("texttospeech.googleapis.com");

    let channel = Channel::from_static("https://texttospeech.googleapis.com")
        .tls_config(tls_config)?
        .connect()
        .await
        .context("Could not connect to Google TTS API")?;

    // TODO: I don't understand how these autogenerated clients work. Is the interceptor really necessary to inject the bearer token?
    let service = TextToSpeechClient::with_interceptor(channel, move |mut req: Request<()>| {
        let token = &*token.header_value().map_err(|_| {
            tonic::Status::new(
                tonic::Code::Internal,
                "Could not get token authorization header value",
            )
        })?;
        let meta = MetadataValue::from_str(token)
            .map_err(|_| tonic::Status::new(tonic::Code::Internal, "Invalid metadata value"))?;
        req.metadata_mut().insert("authorization", meta);
        Ok(req)
    });

    Ok(service)
}

async fn readyz() -> anyhow::Result<()> {
    // check google api readiness by listing the voices
    let api_path = std::env::var("GOOGLE_API_CREDENTIALS")
        .context("Could not find env var GOOGLE_API_CREDENTIALS")?;
    let mut g_service = create_google_api_client(api_path).await?;

    g_service
        .list_voices(ListVoicesRequest {
            language_code: "en-US".to_string(),
        })
        .await?;

    Ok(())
}

struct ChannelDurationNotifier {
    chan_id: ChannelId,
    count: Arc<AtomicUsize>,
    http: Arc<Http>,
}

#[async_trait]
impl VoiceEventHandler for ChannelDurationNotifier {
    async fn act(&self, _ctx: &EventContext<'_>) -> Option<Event> {
        // TODO: automatically leave channel after some amount of time spent idle
        let count_before = self.count.fetch_add(1, Ordering::Relaxed);
        tracing::info!("Been in voice channel for {} minutes!", count_before);
        None
    }
}

#[command]
#[only_in(guilds)]
async fn join(ctx: &Context, msg: &Message) -> CommandResult {
    join_inner(ctx, msg).await
}

async fn join_inner(ctx: &Context, msg: &Message) -> CommandResult {
    let guild = msg
        .guild(&ctx.cache)
        .await
        .ok_or_else(|| anyhow!("Could not retrieve server info"))?;
    let guild_id = guild.id;

    let channel_id = match guild
        .voice_states
        .get(&msg.author.id)
        .and_then(|vs| vs.channel_id)
    {
        Some(c) => c,
        None => {
            msg.reply(ctx, "Not in a voice channel").await?;
            return Ok(());
        }
    };

    let manager = songbird::get(ctx)
        .await
        .expect("Songbird context should be there")
        .clone();

    {
        // check to see if we are already in the same channel as the user. If we are,
        // return without doing anything further. If we are in a different voice channel
        // than the user, tell them that we are already in a voice channel.
        // If we are not in a voice channel at all, we continue onwards.
        if let Some(c) = ctx.data.read().await.get::<CurrentVoiceChannel>() {
            if *c != channel_id {
                msg.reply(ctx, "Already in another voice channel.").await?;
            }
            return Ok(());
        }
    }

    let (handle_lock, success) = manager.join(guild_id, channel_id).await;

    if let Ok(_) = success {
        let chan_id = msg.channel_id;
        let mut handle = handle_lock.lock().await;

        handle.add_global_event(
            Event::Periodic(Duration::from_secs(60), None),
            ChannelDurationNotifier {
                chan_id,
                count: Default::default(),
                http: ctx.http.clone(),
            },
        );

        ctx.data
            .write()
            .await
            .insert::<CurrentVoiceChannel>(channel_id);
    } else {
        msg.channel_id
            .say(&ctx.http, "Could not join voice channel.")
            .await?;
    }

    Ok(())
}

#[command]
#[only_in(guilds)]
async fn leave(ctx: &Context, msg: &Message) -> CommandResult {
    let guild = msg
        .guild(&ctx.cache)
        .await
        .ok_or_else(|| anyhow!("Could not retrieve server info"))?;
    let guild_id = guild.id;

    let channel_id = match guild
        .voice_states
        .get(&msg.author.id)
        .and_then(|vs| vs.channel_id)
    {
        Some(c) => c,
        None => {
            msg.reply(ctx, "You must be in a voice channel to make me leave one")
                .await?;
            return Ok(());
        }
    };

    let manager = songbird::get(ctx)
        .await
        .expect("Songbird Voice client placed in at initialisation.")
        .clone();
    let has_handler = manager.get(guild_id).is_some();

    if has_handler {
        let mut data = ctx.data.write().await;

        if let Some(c) = data.get::<CurrentVoiceChannel>() {
            if *c != channel_id {
                msg.reply(
                    ctx,
                    "You must be in the same voice channel as me to make me leave.",
                )
                .await?;
                return Ok(());
            }
        }

        if let Err(e) = manager.remove(guild_id).await {
            msg.channel_id
                .say(&ctx.http, format!("Failed: {:?}", e))
                .await?;
        }

        data.remove::<CurrentVoiceChannel>();

        msg.channel_id.say(&ctx.http, "Left voice channel").await?;
    } else {
        msg.reply(ctx, "Not in a voice channel").await?;
    }

    Ok(())
}

struct TrackCleanup(tempfile::NamedTempFile);

#[async_trait]
impl VoiceEventHandler for TrackCleanup {
    async fn act(&self, _ctx: &EventContext<'_>) -> Option<Event> {
        // This event is just around so that the tempfile will get destructed
        // after the track has been played and not while it's in the queue.
        None
    }
}

#[command]
#[only_in(guilds)]
async fn say(ctx: &Context, msg: &Message, args: Args) -> CommandResult {
    // try to join the channel the user's in.
    join_inner(ctx, msg).await?;

    let manager = songbird::get(ctx)
        .await
        .expect("Songbird context should be there")
        .clone();

    let guild = msg
        .guild(&ctx.cache)
        .await
        .ok_or_else(|| anyhow!("Could not fetch guild"))?;
    let guild_id = guild.id;

    if let Some(tts_service) = ctx.data.write().await.get_mut::<TtsService>() {
        let req = SynthesizeSpeechRequest {
            input: Some(SynthesisInput {
                input_source: Some(InputSource::Text(args.message().to_string())),
            }),
            voice: Some(VoiceSelectionParams {
                language_code: "en-US".to_string(),
                name: "en-US-Wavenet-D".to_string(),
                ssml_gender: 1, // not necessary, but hey, let's see what happens
            }),
            audio_config: Some(AudioConfig {
                audio_encoding: AudioEncoding::Linear16 as i32,
                speaking_rate: 0.0,
                pitch: 0.0,
                volume_gain_db: 0.0,
                sample_rate_hertz: 0,
                effects_profile_id: vec![],
            }),
        };

        let res = tts_service
            .synthesize_speech(req)
            .await
            .map_err(|s| anyhow!("Could not make TTS API call: {}", s.message()))?;

        if let Some(handler_lock) = manager.get(guild_id) {
            let response = res.into_inner();

            let mut file = tempfile::NamedTempFile::new()?;
            file.write_all(&response.audio_content)?;

            let input = songbird::ffmpeg(file.path())
                .await
                .map_err(|_| anyhow!("Could not create ffmpeg player"))?;

            let (track, track_handle) = create_player(input);

            track_handle.add_event(Event::Track(TrackEvent::End), TrackCleanup(file))?;

            {
                let mut handler = handler_lock.lock().await;
                handler.enqueue(track);
            }
        }
    }

    Ok(())
}

// TODO: what is this
struct ReadyNotifier;

#[async_trait]
impl EventHandler for ReadyNotifier {
    async fn ready(&self, _: Context, ready: Ready) {
        tracing::info!("{} is connected!", ready.user.name);
    }
}

struct CurrentVoiceChannel;

impl TypeMapKey for CurrentVoiceChannel {
    type Value = ChannelId;
}

struct TtsService;

impl TypeMapKey for TtsService {
    type Value = TextToSpeechClient<Channel>;
}

#[group]
#[commands(say, join, leave)]
struct General;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::fmt().init();

    let discord_token =
        std::env::var("DISCORD_TOKEN").context("Could not find env var DISCORD_TOKEN")?;
    let api_path = std::env::var("GOOGLE_API_CREDENTIALS")
        .context("Could not find env var GOOGLE_API_CREDENTIALS")?;

    let service = create_google_api_client(api_path).await?;

    let framework = StandardFramework::new()
        .configure(|c| c.prefix("::"))
        .group(&GENERAL_GROUP);

    let mut client = Client::builder(&discord_token)
        .event_handler(ReadyNotifier)
        .framework(framework)
        .register_songbird()
        .await
        .context("Could not initialize Discord client")?;

    client.data.write().await.insert::<TtsService>(service);

    let _ = client.start().await.map_err(|why| {
        tracing::info!("Client ended: {:?}", why);
    });

    Ok(())
}
