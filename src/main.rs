use std::{path::Path, sync::Arc};

use anyhow::Context as anyhowContext;
use googapis::google::cloud::texttospeech::v1::text_to_speech_client::TextToSpeechClient;
use googapis::google::cloud::texttospeech::v1::ListVoicesRequest;
use gouth::Builder;
use serenity::{
    async_trait,
    client::{bridge::gateway::ShardManager, Context, EventHandler},
    framework::{standard::macros::group, StandardFramework},
    model::prelude::Ready,
    prelude::{Mutex, TypeMapKey},
    Client,
};
use songbird::SerenityInit;
use tonic::{
    metadata::MetadataValue,
    transport::{Certificate, Channel, ClientTlsConfig},
    Request,
};
use tracing_subscriber::EnvFilter;

mod commands;

use commands::{join::*, say::*};

#[tracing::instrument(skip(api_path), err)]
async fn create_google_api_client<C: AsRef<Path> + std::fmt::Debug>(
    api_path: C,
) -> anyhow::Result<TextToSpeechClient<Channel>> {
    tracing::debug!("Loading Google API credentials from {:?}", api_path);

    let token = Builder::new()
        .file(api_path.as_ref())
        .build()
        .context("Could not load Google API credentials")?;

    let tls_config = ClientTlsConfig::new()
        .ca_certificate(Certificate::from_pem(googapis::CERTIFICATES))
        .domain_name("texttospeech.googleapis.com");

    let channel = Channel::from_static("https://texttospeech.googleapis.com")
        .tls_config(tls_config)?
        .connect()
        .await
        .context("Could not connect to Google TTS API")?;

    // TODO: I don't understand how these autogenerated clients work. Is the interceptor really necessary to inject the bearer token?
    let service = TextToSpeechClient::with_interceptor(channel, move |mut req: Request<()>| {
        let token = &*token.header_value().map_err(|_| {
            tonic::Status::new(
                tonic::Code::Internal,
                "Could not get token authorization header value",
            )
        })?;
        let meta = MetadataValue::from_str(token)
            .map_err(|_| tonic::Status::new(tonic::Code::Internal, "Invalid metadata value"))?;
        req.metadata_mut().insert("authorization", meta);
        Ok(req)
    });

    Ok(service)
}

#[tracing::instrument(skip(svc))]
async fn get_voices(svc: &mut TextToSpeechClient<Channel>) -> anyhow::Result<Vec<String>> {
    tracing::debug!("Fetching list of Wavenet voices from Google...");
    let req = ListVoicesRequest {
        language_code: "en-US".to_string(),
    };

    let res = svc.list_voices(req).await?.into_inner();

    let voices = res
        .voices
        .into_iter()
        .filter_map(|v| {
            if v.name.contains("Wavenet") {
                Some(v.name)
            } else {
                None
            }
        })
        .collect::<Vec<_>>();

    tracing::info!("Loading bot with {} voices", voices.len());

    Ok(voices)
}

struct ReadyNotifier;
#[async_trait]
impl EventHandler for ReadyNotifier {
    async fn ready(&self, _: Context, ready: Ready) {
        tracing::info!("{} is connected!", ready.user.name);
    }
}

#[group]
#[commands(say, join, leave, skip)]
struct General;

pub struct ShardManagerContainer;

impl TypeMapKey for ShardManagerContainer {
    type Value = Arc<Mutex<ShardManager>>;
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let subscriber = tracing_subscriber::FmtSubscriber::builder()
        .with_env_filter(EnvFilter::from_default_env())
        .finish();
    tracing::subscriber::set_global_default(subscriber).expect("failed to start the logger");

    let discord_token =
        std::env::var("DISCORD_TOKEN").context("Could not find env var DISCORD_TOKEN")?;
    let api_path = std::env::var("GOOGLE_API_CREDENTIALS")
        .context("Could not find env var GOOGLE_API_CREDENTIALS")?;

    let mut service = create_google_api_client(api_path).await?;

    let framework = StandardFramework::new()
        .configure(|c| c.prefix("::"))
        .group(&GENERAL_GROUP);

    let mut client = Client::builder(&discord_token)
        .event_handler(ReadyNotifier)
        .framework(framework)
        .register_songbird()
        .await
        .context("Could not initialize Discord client")?;

    let voices = get_voices(&mut service).await?;

    {
        let mut data = client.data.write().await;
        data.insert::<ShardManagerContainer>(client.shard_manager.clone());
        data.insert::<TtsService>(service);
        data.insert::<Voices>(voices);
    }

    let shard_manager = client.shard_manager.clone();

    tokio::spawn(async move {
        tokio::signal::ctrl_c()
            .await
            .expect("Could not register ctrl+c handler");
        shard_manager.lock().await.shutdown_all().await;
    });

    let _ = client.start().await.map_err(|why| {
        tracing::info!("Client ended: {:?}", why);
    });

    Ok(())
}
